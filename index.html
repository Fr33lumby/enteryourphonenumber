<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <!-- Mobile viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Flight Sim Phone Input â€“ UFO & Contrails Edition</title>
    <style>
      body { margin: 0; overflow: hidden; }
      /* Ensure the canvas is fixed in the background */
      canvas { 
        display: block; 
        position: fixed; 
        top: 0; 
        left: 0; 
        z-index: 0;
      }
      #hud {
        position: fixed;
        top: 10px;
        left: 10px;
        padding: 10px;
        background: rgba(0,0,0,0.7);
        color: #fff;
        font-family: monospace;
        font-size: 16px;
        z-index: 100;
      }
      #wastedScreen {
        position: fixed;
        top: 0; left: 0;
        width: 100%; height: 100%;
        background: rgba(0,0,0,0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        color: red;
        font-size: 100px;
        font-family: sans-serif;
        letter-spacing: 5px;
        z-index: 9999;
        opacity: 0;
        transition: opacity 0.5s ease;
      }
      #wastedScreen.visible { opacity: 1; }
      /* Drop-Off Overlay */
      #dropOffOverlay {
        position: fixed;
        top: 0; left: 0;
        width: 100%; height: 100%;
        background: rgba(0,0,0,0.9);
        z-index: 200;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }
      #dropOffOverlay div {
        color: #fff;
        font-size: 20px;
        margin-bottom: 20px;
      }
      #dropOffOverlay input {
        font-size: 18px;
        padding: 8px;
        width: 300px;
        text-align: center;
        margin-bottom: 20px;
        pointer-events: none;
      }
      /* Joystick Styles */
      .joystick {
        position: fixed;
        bottom: 20px;
        width: 100px;
        height: 100px;
        border: 2px solid rgba(255,255,255,0.8);
        border-radius: 50%;
        background: rgba(0,0,0,0.3);
        touch-action: none;
        z-index: 101;
      }
      #joystickLeft { left: 20px; }
      #joystickRight { right: 20px; }
      .joystick .joystick-thumb {
        position: absolute;
        width: 50px;
        height: 50px;
        background: rgba(255,255,255,0.8);
        border-radius: 50%;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }
    </style>
  </head>
  <body>
    <div id="hud"></div>
    <div id="wastedScreen">WASTED</div>
    <!-- Drop-Off Overlay -->
    <div id="dropOffOverlay">
      <div id="dropOffText">Your Number:</div>
      <input type="text" id="dropOffInput" readonly />
    </div>
    <!-- Touch Joysticks -->
    <div id="joystickLeft" class="joystick">
      <div class="joystick-thumb"></div>
    </div>
    <div id="joystickRight" class="joystick">
      <div class="joystick-thumb"></div>
    </div>
    <!-- Include Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Include FontLoader and TextGeometry -->
    <script src="https://threejs.org/examples/jsm/loaders/FontLoader.js"></script>
    <script src="https://threejs.org/examples/jsm/geometries/TextGeometry.js"></script>
    <script>
      /* --- Global Variables --- */
      let scene, camera, renderer;
      let plane, ground, landingPad;
      let digitTargets = [];
      let phoneNumber = "";
      const maxDigits = 10;
      const numTargets = 500;
      const fixedTargetValues = ["0","1","2","3","4","5","6","7","8","9","DEL"];
      
      // UFO variables
      let ufos = [];
      
      // Flight control variables (using pitch and yaw)
      let pitchAngle = 0, yawAngle = 0;
      let speed = 1.0, maxSpeed = 4000.0, minSpeed = 0.1, acceleration = 0.1;
      const pitchSpeed = 0.03, yawSpeed = 0.03;
      let oldTime = 0;
      const keysPressed = {};
      
      // Joystick variables (normalized values between -1 and 1)
      let joystickLeft = { x: 0, y: 0 };  // Controls pitch & yaw
      let joystickRight = { y: 0 };         // Controls throttle
      
      // Flags for landing and freezing flight
      let landingTriggered = false;
      let flightFrozen = false;
      
      // Font variable
      let font = null;
      
      // Helper: Generate random digit string
      function generateRandomNumberString(minLen, maxLen) {
        const len = Math.floor(Math.random() * (maxLen - minLen + 1)) + minLen;
        let str = "";
        for (let i = 0; i < len; i++) {
          str += Math.floor(Math.random() * 10);
        }
        return str;
      }
      
      // Create runway texture: grey with white dashed center line
      function createRunwayTexture() {
        const width = 1000, height = 100;
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = "#666666";
        ctx.fillRect(0, 0, width, height);
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 4;
        ctx.setLineDash([40, 30]);
        ctx.beginPath();
        ctx.moveTo(0, height / 2);
        ctx.lineTo(width, height / 2);
        ctx.stroke();
        return new THREE.CanvasTexture(canvas);
      }
      
      // Create ground texture: striped green
      function createStripedTexture() {
        const size = 512;
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const context = canvas.getContext('2d');
        context.fillStyle = "#33aa33";
        context.fillRect(0, 0, size, size);
        context.fillStyle = "#ffffff";
        const stripeHeight = 30;
        for (let y = 0; y < size; y += stripeHeight * 2) {
          context.fillRect(0, y, size, stripeHeight);
        }
        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(100, 100);
        return texture;
      }
      
      // Create UFO triangle geometry by extruding a triangle shape.
      function createUFOGeometry() {
        const shape = new THREE.Shape();
        shape.moveTo(0, 0);
        shape.lineTo(30, 0);
        shape.lineTo(15, 25);
        shape.lineTo(0, 0);
        const extrudeSettings = { depth: 5, bevelEnabled: false };
        return new THREE.ExtrudeGeometry(shape, extrudeSettings);
      }
      
      // Create UFOs
      function createUFOs() {
        const ufoGeom = createUFOGeometry();
        for (let i = 0; i < 10; i++) {
          const material = new THREE.MeshPhongMaterial({ color: 0x00ff00, emissive: 0x003300 });
          const ufo = new THREE.Mesh(ufoGeom, material);
          ufo.position.set(
            THREE.MathUtils.randFloatSpread(10000),
            THREE.MathUtils.randFloat(100, 1000),
            THREE.MathUtils.randFloatSpread(10000)
          );
          // Assign random velocity stored in userData
          ufo.userData.velocity = new THREE.Vector3(
            THREE.MathUtils.randFloatSpread(2),
            THREE.MathUtils.randFloatSpread(2),
            THREE.MathUtils.randFloatSpread(2)
          );
          ufos.push(ufo);
          scene.add(ufo);
        }
      }
      
      // Create sky contrails overlay using GridHelper.
      function createSkyContrails() {
        const grid = new THREE.GridHelper(10000, 100, 0xffffff, 0xffffff);
        grid.position.y = 3000; // high up
        grid.material.opacity = 0.1;
        grid.material.transparent = true;
        grid.rotation.x = Math.PI / 2;
        scene.add(grid);
      }
      
      // Load font
      const fontLoader = new THREE.FontLoader();
      fontLoader.load("https://threejs.org/examples/fonts/helvetiker_regular.typeface.json", function(loadedFont) {
        font = loadedFont;
        createDigitTargets();
      });
      
      init();
      createUFOs();
      createSkyContrails();
      setupJoysticks();
      requestAnimationFrame(animate);
      
      function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
      
        camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 3000);
        camera.position.set(0, 150, 800);
      
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
      
        // Create airplane.
        plane = new THREE.Group();
        const fuselageGeom = new THREE.BoxGeometry(0.3, 0.3, 3);
        const fuselageMat = new THREE.MeshPhongMaterial({ color: 0x999999 });
        const fuselage = new THREE.Mesh(fuselageGeom, fuselageMat);
        plane.add(fuselage);
      
        const wingGeom = new THREE.BoxGeometry(4, 0.1, 0.5);
        const wingMat = new THREE.MeshPhongMaterial({ color: 0x666666 });
        const wing = new THREE.Mesh(wingGeom, wingMat);
        wing.position.y = 0;
        plane.add(wing);
      
        const tailHGeom = new THREE.BoxGeometry(1, 0.1, 0.3);
        const tailH = new THREE.Mesh(tailHGeom, wingMat);
        tailH.position.set(0, 0.2, -1.4);
        plane.add(tailH);
      
        const tailVGeom = new THREE.BoxGeometry(0.1, 0.5, 0.3);
        const tailV = new THREE.Mesh(tailVGeom, wingMat);
        tailV.position.set(0, 0.25, -1.4);
        plane.add(tailV);
      
        plane.position.set(0, 150, 800);
        scene.add(plane);
      
        // Create landing pad (runway) at ground level.
        landingPad = new THREE.Mesh(
          new THREE.PlaneGeometry(1000, 100),
          new THREE.MeshBasicMaterial({ map: createRunwayTexture(), side: THREE.DoubleSide })
        );
        landingPad.rotation.x = -Math.PI / 2;
        landingPad.position.set(0, 0.11, 1500);
        scene.add(landingPad);
      
        // Add two skyscrapers.
        const buildingGeom = new THREE.BoxGeometry(200, 1200, 200);
        const buildingMat = new THREE.MeshPhongMaterial({ color: 0x888888 });
        const skyscraper1 = new THREE.Mesh(buildingGeom, buildingMat);
        skyscraper1.position.set(-300, 600, 1500);
        scene.add(skyscraper1);
        const skyscraper2 = new THREE.Mesh(buildingGeom, buildingMat);
        skyscraper2.position.set(300, 600, 1700);
        scene.add(skyscraper2);
      
        // Create ground.
        ground = new THREE.Mesh(
          new THREE.PlaneGeometry(10000, 10000),
          new THREE.MeshPhongMaterial({ map: createStripedTexture() })
        );
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);
      
        // Lighting.
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(50, 100, 50);
        scene.add(directionalLight);
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
      
        window.addEventListener("resize", onWindowResize, false);
        document.addEventListener("keydown", keyDownHandler);
        document.addEventListener("keyup", keyUpHandler);
      }
      
      function createDigitTargets() {
        if (!font) return;
        for (let i = 0; i < numTargets; i++) {
          let useRandom = Math.random() < 0.5;
          let val = useRandom ? generateRandomNumberString(3, 5)
                              : fixedTargetValues[Math.floor(Math.random() * fixedTargetValues.length)];
          let material;
          if (val === "DEL") {
            material = new THREE.MeshPhongMaterial({ color: 0xff4444 });
          } else if (val.length > 1) {
            material = new THREE.MeshPhongMaterial({ color: 0x88ff88 });
          } else {
            material = new THREE.MeshPhongMaterial({ color: 0xffffff });
          }
          let textGeom = new THREE.TextGeometry(val, {
            font: font,
            size: 20,
            height: 4,
            curveSegments: 8
          });
          textGeom.center();
          let textMesh = new THREE.Mesh(textGeom, material);
          textMesh.userData.value = val;
          repositionTarget(textMesh);
          scene.add(textMesh);
          digitTargets.push(textMesh);
        }
      }
      
      function repositionTarget(target) {
        let center = plane.position.clone();
        const minDist = 200, maxDist = 1000;
        let distance = THREE.MathUtils.randFloat(minDist, maxDist);
        let theta = THREE.MathUtils.randFloat(0, Math.PI * 2);
        let phi = THREE.MathUtils.randFloat(0, Math.PI);
        let offset = new THREE.Vector3(
          distance * Math.sin(phi) * Math.cos(theta),
          distance * Math.cos(phi),
          distance * Math.sin(phi) * Math.sin(theta)
        );
        target.position.copy(center.add(offset));
      }
      
      function updateDynamicTargets() {
        const maxDistance = 1200;
        for (let i = 0; i < digitTargets.length; i++) {
          let target = digitTargets[i];
          if (target.position.distanceTo(plane.position) > maxDistance) {
            repositionTarget(target);
          }
        }
      }
      
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      
      function animate(time) {
        const delta = (time - oldTime) / 16.6667;
        oldTime = time;
        requestAnimationFrame(animate);
        if (!flightFrozen) updateFlight(delta);
        updateDynamicTargets();
        checkDigitCollisions();
        checkLanding();
        checkSkyscraperCollisions();
        updateUFOs(delta);
        updateHUD();
        renderer.render(scene, camera);
        if (plane.position.y < -10 && !landingTriggered) {
          triggerWasted("Crashed into the ground!");
        }
      }
      
      // Update flight controls using both keyboard and joystick input.
      function updateFlight(delta) {
        // Joystick input for pitch and yaw (left joystick)
        let joystickPitch = joystickLeft.y;  // Upward movement increases pitch
        let joystickYaw = joystickLeft.x;
      
        // Keyboard fallback for pitch/yaw
        let keyboardPitch = 0;
        if (keysPressed["ArrowUp"]) keyboardPitch += 1;
        if (keysPressed["ArrowDown"]) keyboardPitch -= 1;
        let keyboardYaw = 0;
        if (keysPressed["ArrowLeft"]) keyboardYaw += 1;
        if (keysPressed["ArrowRight"]) keyboardYaw -= 1;
      
        // Combine inputs
        let totalPitch = keyboardPitch + joystickPitch;
        let totalYaw = keyboardYaw + joystickYaw;
      
        pitchAngle += totalPitch * pitchSpeed * delta;
        yawAngle   += totalYaw * yawSpeed * delta;
      
        // Throttle control using right joystick (vertical axis) plus keyboard W/S
        let keyboardThrottle = 0;
        if (keysPressed["KeyW"]) keyboardThrottle += 1;
        if (keysPressed["KeyS"]) keyboardThrottle -= 1;
        let throttleInput = keyboardThrottle + joystickRight.y;  // Up on joystick accelerates
      
        speed = Math.min(Math.max(speed + throttleInput * acceleration * delta, minSpeed), maxSpeed);
      
        // Update plane orientation and position.
        let qPitch = new THREE.Quaternion();
        qPitch.setFromAxisAngle(new THREE.Vector3(1, 0, 0), pitchAngle);
        let qYaw = new THREE.Quaternion();
        qYaw.setFromAxisAngle(new THREE.Vector3(0, 1, 0), yawAngle);
        plane.quaternion.copy(qYaw.multiply(qPitch));
        let forward = new THREE.Vector3(0, 0, 1);
        forward.applyQuaternion(plane.quaternion);
        plane.position.add(forward.multiplyScalar(speed * delta));
        let localCamOffset = new THREE.Vector3(0, 5, -20);
        localCamOffset.applyQuaternion(plane.quaternion);
        let desiredCameraPos = plane.position.clone().add(localCamOffset);
        camera.position.lerp(desiredCameraPos, 0.1);
        camera.lookAt(plane.position);
      }
      
      function checkDigitCollisions() {
        const targetRadius = 12;
        for (let i = 0; i < digitTargets.length; i++) {
          let target = digitTargets[i];
          let dist = target.position.distanceTo(plane.position);
          if (dist < targetRadius + 2) {
            processDigitCollision(target);
            resetAllDigitTargets();
            break;
          }
        }
      }
      
      function processDigitCollision(target) {
        let val = target.userData.value;
        if (val === "DEL") {
          phoneNumber = phoneNumber.slice(0, -1);
        } else {
          if (val.length > 1) {
            if (phoneNumber.length + val.length <= maxDigits) {
              phoneNumber += val;
            }
          } else {
            if (phoneNumber.length < maxDigits) {
              phoneNumber += val;
            }
          }
        }
      }
      
      function resetAllDigitTargets() {
        for (let i = 0; i < digitTargets.length; i++) {
          repositionTarget(digitTargets[i]);
        }
      }
      
      // Landing detection.
      function checkLanding() {
        let landingCenter = new THREE.Vector2(landingPad.position.x, landingPad.position.z);
        let planePos2D = new THREE.Vector2(plane.position.x, plane.position.z);
        let horizDist = landingCenter.distanceTo(planePos2D);
        if (!landingTriggered && horizDist < 300 && plane.position.y < 40) {
          landingTriggered = true;
          flightFrozen = true;
          const overlay = document.getElementById("dropOffOverlay");
          document.getElementById("dropOffInput").value = formatPhoneNumber(phoneNumber);
          overlay.style.display = "flex";
        }
      }
      
      // Check collision with skyscrapers.
      function checkSkyscraperCollisions() {
        if (Math.abs(plane.position.x - (-300)) < 105 &&
            Math.abs(plane.position.z - 1500) < 105 &&
            plane.position.y < 1200) {
          triggerWasted("Hit a skyscraper!");
        }
        if (Math.abs(plane.position.x - 300) < 105 &&
            Math.abs(plane.position.z - 1700) < 105 &&
            plane.position.y < 1200) {
          triggerWasted("Hit a skyscraper!");
        }
      }
      
      // Update UFOs.
      function updateUFOs(delta) {
        ufos.forEach(ufo => {
          ufo.position.add(ufo.userData.velocity.clone().multiplyScalar(delta * 50));
          if (ufo.position.x > 5000) ufo.position.x = -5000;
          if (ufo.position.x < -5000) ufo.position.x = 5000;
          if (ufo.position.y > 3000) ufo.position.y = 100;
          if (ufo.position.y < 100) ufo.position.y = 3000;
          if (ufo.position.z > 5000) ufo.position.z = -5000;
          if (ufo.position.z < -5000) ufo.position.z = 5000;
          if (Math.random() < 0.05) {
            ufo.material.color.setHex(Math.random() * 0xffffff);
          }
        });
      }
      
      function copyToClipboard(text) {
        const tempInput = document.createElement("input");
        document.body.appendChild(tempInput);
        tempInput.value = text;
        tempInput.select();
        try {
          document.execCommand("copy");
          alert("Copied to clipboard!");
        } catch (err) {
          alert("Failed to copy text: " + err);
        }
        document.body.removeChild(tempInput);
      }
      
      function updateHUD() {
        let altitude = plane.position.y.toFixed(1);
        let currentSpeed = speed.toFixed(2);
        let forward = new THREE.Vector3(0, 0, 1);
        forward.applyQuaternion(plane.quaternion);
        forward.y = 0;
        forward.normalize();
        let headingDeg = THREE.MathUtils.radToDeg(Math.atan2(forward.x, forward.z)).toFixed(1);
        let formattedNumber = formatPhoneNumber(phoneNumber);
        const hud = document.getElementById("hud");
        hud.innerHTML = `
          <strong>Flight Info</strong><br>
          Speed: ${currentSpeed}<br>
          Altitude: ${altitude}<br>
          Heading: ${headingDeg}&deg;<br><br>
          <strong>Phone Number Input</strong><br>
          ${formattedNumber}
        `;
      }
      
      function formatPhoneNumber(numStr) {
        let result = "+43 ";
        for (let i = 0; i < numStr.length; i++) {
          result += numStr[i];
          if (i === 2 || i === 5 || i === 8) {
            result += " ";
          }
        }
        return result;
      }
      
      function triggerWasted(reason) {
        console.log(reason);
        const wastedScreen = document.getElementById("wastedScreen");
        wastedScreen.classList.add("visible");
        document.removeEventListener("keydown", keyDownHandler);
        document.removeEventListener("keyup", keyUpHandler);
        setTimeout(() => { location.reload(); }, 3000);
      }
      
      function keyDownHandler(e) { keysPressed[e.code] = true; }
      function keyUpHandler(e) { keysPressed[e.code] = false; }
      
      // --- Touch Joystick Setup ---
      function setupJoysticks() {
        setupJoystick("joystickLeft", joystickLeft, false);
        setupJoystick("joystickRight", joystickRight, true);
      }
      
      // Sets up a joystick for a given container.
      // If isVerticalOnly is true, only the vertical axis is used.
      function setupJoystick(joystickId, joystickObj, isVerticalOnly) {
        const container = document.getElementById(joystickId);
        const thumb = container.querySelector('.joystick-thumb');
        let maxRadius = container.clientWidth / 2;
        
        function updateJoystick(clientX, clientY) {
          let rect = container.getBoundingClientRect();
          let centerX = rect.left + rect.width / 2;
          let centerY = rect.top + rect.height / 2;
          let dx = clientX - centerX;
          let dy = clientY - centerY;
          let distance = Math.sqrt(dx * dx + dy * dy);
          if (distance > maxRadius) {
            let angle = Math.atan2(dy, dx);
            dx = Math.cos(angle) * maxRadius;
            dy = Math.sin(angle) * maxRadius;
          }
          thumb.style.transform = `translate(${dx}px, ${dy}px)`;
          let normX = dx / maxRadius;
          let normY = dy / maxRadius;
          if (isVerticalOnly) {
            // Invert vertical so that upward movement gives positive throttle.
            joystickObj.y = -normY;
          } else {
            joystickObj.x = normX;
            joystickObj.y = -normY;
          }
        }
        
        function resetJoystick() {
          joystickObj.x = 0;
          joystickObj.y = 0;
          thumb.style.transform = 'translate(0px, 0px)';
        }
        
        // Touch events with passive: false
        container.addEventListener("touchstart", (e) => {
          e.preventDefault();
          const touch = e.touches[0];
          updateJoystick(touch.clientX, touch.clientY);
        }, { passive: false });
        container.addEventListener("touchmove", (e) => {
          e.preventDefault();
          const touch = e.touches[0];
          updateJoystick(touch.clientX, touch.clientY);
        }, { passive: false });
        container.addEventListener("touchend", (e) => {
          e.preventDefault();
          resetJoystick();
        }, { passive: false });
        
        // Mouse events
        let mouseDown = false;
        container.addEventListener("mousedown", (e) => {
          e.preventDefault();
          mouseDown = true;
          updateJoystick(e.clientX, e.clientY);
        });
        window.addEventListener("mousemove", (e) => {
          if (!mouseDown) return;
          updateJoystick(e.clientX, e.clientY);
        });
        window.addEventListener("mouseup", (e) => {
          if (!mouseDown) return;
          mouseDown = false;
          resetJoystick();
        });
      }
    </script>
  </body>
</html>
